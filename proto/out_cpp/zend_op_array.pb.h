// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: zend_op_array.proto

#ifndef PROTOBUF_zend_5fop_5farray_2eproto__INCLUDED
#define PROTOBUF_zend_5fop_5farray_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "zend_types.pb.h"
// @@protoc_insertion_point(includes)
namespace gphp {
class Opline;
class OplineDefaultTypeInternal;
extern OplineDefaultTypeInternal _Opline_default_instance_;
class ZendOpArray;
class ZendOpArrayDefaultTypeInternal;
extern ZendOpArrayDefaultTypeInternal _ZendOpArray_default_instance_;
}  // namespace gphp

namespace gphp {

namespace protobuf_zend_5fop_5farray_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_zend_5fop_5farray_2eproto

enum Opline_OpType {
  Opline_OpType_CONST = 1,
  Opline_OpType_TMP_VAR = 2,
  Opline_OpType_VAR = 4,
  Opline_OpType_UNUSED = 8,
  Opline_OpType_CV = 16
};
bool Opline_OpType_IsValid(int value);
const Opline_OpType Opline_OpType_OpType_MIN = Opline_OpType_CONST;
const Opline_OpType Opline_OpType_OpType_MAX = Opline_OpType_CV;
const int Opline_OpType_OpType_ARRAYSIZE = Opline_OpType_OpType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Opline_OpType_descriptor();
inline const ::std::string& Opline_OpType_Name(Opline_OpType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Opline_OpType_descriptor(), value);
}
inline bool Opline_OpType_Parse(
    const ::std::string& name, Opline_OpType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Opline_OpType>(
    Opline_OpType_descriptor(), name, value);
}
enum Opcode {
  NOP = 0,
  ADD = 1,
  SUB = 2,
  MUL = 3,
  DIV = 4,
  MOD = 5,
  SL = 6,
  SR = 7,
  CONCAT = 8,
  BW_OR = 9,
  BW_AND = 10,
  BW_XOR = 11,
  BW_NOT = 12,
  BOOL_NOT = 13,
  BOOL_XOR = 14,
  IS_IDENTICAL = 15,
  IS_NOT_IDENTICAL = 16,
  IS_EQUAL = 17,
  IS_NOT_EQUAL = 18,
  IS_SMALLER = 19,
  IS_SMALLER_OR_EQUAL = 20,
  CAST = 21,
  QM_ASSIGN = 22,
  ASSIGN_ADD = 23,
  ASSIGN_SUB = 24,
  ASSIGN_MUL = 25,
  ASSIGN_DIV = 26,
  ASSIGN_MOD = 27,
  ASSIGN_SL = 28,
  ASSIGN_SR = 29,
  ASSIGN_CONCAT = 30,
  ASSIGN_BW_OR = 31,
  ASSIGN_BW_AND = 32,
  ASSIGN_BW_XOR = 33,
  PRE_INC = 34,
  PRE_DEC = 35,
  POST_INC = 36,
  POST_DEC = 37,
  ASSIGN = 38,
  ASSIGN_REF = 39,
  ECHO = 40,
  GENERATOR_CREATE = 41,
  JMP = 42,
  JMPZ = 43,
  JMPNZ = 44,
  JMPZNZ = 45,
  JMPZ_EX = 46,
  JMPNZ_EX = 47,
  CASE = 48,
  CHECK_VAR = 49,
  SEND_VAR_NO_REF_EX = 50,
  MAKE_REF = 51,
  BOOL = 52,
  FAST_CONCAT = 53,
  ROPE_INIT = 54,
  ROPE_ADD = 55,
  ROPE_END = 56,
  BEGIN_SILENCE = 57,
  END_SILENCE = 58,
  INIT_FCALL_BY_NAME = 59,
  DO_FCALL = 60,
  INIT_FCALL = 61,
  RETURN = 62,
  RECV = 63,
  RECV_INIT = 64,
  SEND_VAL = 65,
  SEND_VAR_EX = 66,
  SEND_REF = 67,
  NEW = 68,
  INIT_NS_FCALL_BY_NAME = 69,
  FREE = 70,
  INIT_ARRAY = 71,
  ADD_ARRAY_ELEMENT = 72,
  INCLUDE_OR_EVAL = 73,
  UNSET_VAR = 74,
  UNSET_DIM = 75,
  UNSET_OBJ = 76,
  FE_RESET_R = 77,
  FE_FETCH_R = 78,
  EXIT = 79,
  FETCH_R = 80,
  FETCH_DIM_R = 81,
  FETCH_OBJ_R = 82,
  FETCH_W = 83,
  FETCH_DIM_W = 84,
  FETCH_OBJ_W = 85,
  FETCH_RW = 86,
  FETCH_DIM_RW = 87,
  FETCH_OBJ_RW = 88,
  FETCH_IS = 89,
  FETCH_DIM_IS = 90,
  FETCH_OBJ_IS = 91,
  FETCH_FUNC_ARG = 92,
  FETCH_DIM_FUNC_ARG = 93,
  FETCH_OBJ_FUNC_ARG = 94,
  FETCH_UNSET = 95,
  FETCH_DIM_UNSET = 96,
  FETCH_OBJ_UNSET = 97,
  FETCH_LIST = 98,
  FETCH_CONSTANT = 99,
  EXT_STMT = 101,
  EXT_FCALL_BEGIN = 102,
  EXT_FCALL_END = 103,
  EXT_NOP = 104,
  TICKS = 105,
  SEND_VAR_NO_REF = 106,
  CATCH = 107,
  THROW = 108,
  FETCH_CLASS = 109,
  CLONE = 110,
  RETURN_BY_REF = 111,
  INIT_METHOD_CALL = 112,
  INIT_STATIC_METHOD_CALL = 113,
  ISSET_ISEMPTY_VAR = 114,
  ISSET_ISEMPTY_DIM_OBJ = 115,
  SEND_VAL_EX = 116,
  SEND_VAR = 117,
  INIT_USER_CALL = 118,
  SEND_ARRAY = 119,
  SEND_USER = 120,
  STRLEN = 121,
  DEFINED = 122,
  TYPE_CHECK = 123,
  VERIFY_RETURN_TYPE = 124,
  FE_RESET_RW = 125,
  FE_FETCH_RW = 126,
  FE_FREE = 127,
  INIT_DYNAMIC_CALL = 128,
  DO_ICALL = 129,
  DO_UCALL = 130,
  DO_FCALL_BY_NAME = 131,
  PRE_INC_OBJ = 132,
  PRE_DEC_OBJ = 133,
  POST_INC_OBJ = 134,
  POST_DEC_OBJ = 135,
  ASSIGN_OBJ = 136,
  OP_DATA = 137,
  INSTANCEOF = 138,
  DECLARE_CLASS = 139,
  DECLARE_INHERITED_CLASS = 140,
  DECLARE_FUNCTION = 141,
  YIELD_FROM = 142,
  DECLARE_CONST = 143,
  ADD_INTERFACE = 144,
  DECLARE_INHERITED_CLASS_DELAYED = 145,
  VERIFY_ABSTRACT_CLASS = 146,
  ASSIGN_DIM = 147,
  ISSET_ISEMPTY_PROP_OBJ = 148,
  HANDLE_EXCEPTION = 149,
  USER_OPCODE = 150,
  ASSERT_CHECK = 151,
  JMP_SET = 152,
  DECLARE_LAMBDA_FUNCTION = 153,
  ADD_TRAIT = 154,
  BIND_TRAITS = 155,
  SEPARATE = 156,
  FETCH_CLASS_NAME = 157,
  CALL_TRAMPOLINE = 158,
  DISCARD_EXCEPTION = 159,
  YIELD = 160,
  GENERATOR_RETURN = 161,
  FAST_CALL = 162,
  FAST_RET = 163,
  RECV_VARIADIC = 164,
  SEND_UNPACK = 165,
  POW = 166,
  ASSIGN_POW = 167,
  BIND_GLOBAL = 168,
  COALESCE = 169,
  SPACESHIP = 170,
  DECLARE_ANON_CLASS = 171,
  DECLARE_ANON_INHERITED_CLASS = 172,
  FETCH_STATIC_PROP_R = 173,
  FETCH_STATIC_PROP_W = 174,
  FETCH_STATIC_PROP_RW = 175,
  FETCH_STATIC_PROP_IS = 176,
  FETCH_STATIC_PROP_FUNC_ARG = 177,
  FETCH_STATIC_PROP_UNSET = 178,
  UNSET_STATIC_PROP = 179,
  ISSET_ISEMPTY_STATIC_PROP = 180,
  FETCH_CLASS_CONSTANT = 181,
  BIND_LEXICAL = 182,
  BIND_STATIC = 183,
  FETCH_THIS = 184,
  ISSET_ISEMPTY_THIS = 186
};
bool Opcode_IsValid(int value);
const Opcode Opcode_MIN = NOP;
const Opcode Opcode_MAX = ISSET_ISEMPTY_THIS;
const int Opcode_ARRAYSIZE = Opcode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Opcode_descriptor();
inline const ::std::string& Opcode_Name(Opcode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Opcode_descriptor(), value);
}
inline bool Opcode_Parse(
    const ::std::string& name, Opcode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Opcode>(
    Opcode_descriptor(), name, value);
}
// ===================================================================

class Opline : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gphp.Opline) */ {
 public:
  Opline();
  virtual ~Opline();

  Opline(const Opline& from);

  inline Opline& operator=(const Opline& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Opline(Opline&& from) noexcept
    : Opline() {
    *this = ::std::move(from);
  }

  inline Opline& operator=(Opline&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Opline& default_instance();

  static inline const Opline* internal_default_instance() {
    return reinterpret_cast<const Opline*>(
               &_Opline_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Opline* other);
  friend void swap(Opline& a, Opline& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Opline* New() const PROTOBUF_FINAL { return New(NULL); }

  Opline* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Opline& from);
  void MergeFrom(const Opline& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Opline* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Opline_OpType OpType;
  static const OpType CONST =
    Opline_OpType_CONST;
  static const OpType TMP_VAR =
    Opline_OpType_TMP_VAR;
  static const OpType VAR =
    Opline_OpType_VAR;
  static const OpType UNUSED =
    Opline_OpType_UNUSED;
  static const OpType CV =
    Opline_OpType_CV;
  static inline bool OpType_IsValid(int value) {
    return Opline_OpType_IsValid(value);
  }
  static const OpType OpType_MIN =
    Opline_OpType_OpType_MIN;
  static const OpType OpType_MAX =
    Opline_OpType_OpType_MAX;
  static const int OpType_ARRAYSIZE =
    Opline_OpType_OpType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OpType_descriptor() {
    return Opline_OpType_descriptor();
  }
  static inline const ::std::string& OpType_Name(OpType value) {
    return Opline_OpType_Name(value);
  }
  static inline bool OpType_Parse(const ::std::string& name,
      OpType* value) {
    return Opline_OpType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .gphp.Opcode opcode = 1;
  bool has_opcode() const;
  void clear_opcode();
  static const int kOpcodeFieldNumber = 1;
  ::gphp::Opcode opcode() const;
  void set_opcode(::gphp::Opcode value);

  // optional uint32 op1 = 2;
  bool has_op1() const;
  void clear_op1();
  static const int kOp1FieldNumber = 2;
  ::google::protobuf::uint32 op1() const;
  void set_op1(::google::protobuf::uint32 value);

  // optional uint32 op2 = 4;
  bool has_op2() const;
  void clear_op2();
  static const int kOp2FieldNumber = 4;
  ::google::protobuf::uint32 op2() const;
  void set_op2(::google::protobuf::uint32 value);

  // optional uint32 result = 6;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 6;
  ::google::protobuf::uint32 result() const;
  void set_result(::google::protobuf::uint32 value);

  // optional uint32 extended_value = 8;
  bool has_extended_value() const;
  void clear_extended_value();
  static const int kExtendedValueFieldNumber = 8;
  ::google::protobuf::uint32 extended_value() const;
  void set_extended_value(::google::protobuf::uint32 value);

  // optional uint32 lineno = 9;
  bool has_lineno() const;
  void clear_lineno();
  static const int kLinenoFieldNumber = 9;
  ::google::protobuf::uint32 lineno() const;
  void set_lineno(::google::protobuf::uint32 value);

  // optional .gphp.Opline.OpType result_type = 7;
  bool has_result_type() const;
  void clear_result_type();
  static const int kResultTypeFieldNumber = 7;
  ::gphp::Opline_OpType result_type() const;
  void set_result_type(::gphp::Opline_OpType value);

  // optional .gphp.Opline.OpType op1_type = 3;
  bool has_op1_type() const;
  void clear_op1_type();
  static const int kOp1TypeFieldNumber = 3;
  ::gphp::Opline_OpType op1_type() const;
  void set_op1_type(::gphp::Opline_OpType value);

  // optional .gphp.Opline.OpType op2_type = 5;
  bool has_op2_type() const;
  void clear_op2_type();
  static const int kOp2TypeFieldNumber = 5;
  ::gphp::Opline_OpType op2_type() const;
  void set_op2_type(::gphp::Opline_OpType value);

  // @@protoc_insertion_point(class_scope:gphp.Opline)
 private:
  void set_has_opcode();
  void clear_has_opcode();
  void set_has_op1();
  void clear_has_op1();
  void set_has_op1_type();
  void clear_has_op1_type();
  void set_has_op2();
  void clear_has_op2();
  void set_has_op2_type();
  void clear_has_op2_type();
  void set_has_result();
  void clear_has_result();
  void set_has_result_type();
  void clear_has_result_type();
  void set_has_extended_value();
  void clear_has_extended_value();
  void set_has_lineno();
  void clear_has_lineno();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int opcode_;
  ::google::protobuf::uint32 op1_;
  ::google::protobuf::uint32 op2_;
  ::google::protobuf::uint32 result_;
  ::google::protobuf::uint32 extended_value_;
  ::google::protobuf::uint32 lineno_;
  int result_type_;
  int op1_type_;
  int op2_type_;
  friend struct protobuf_zend_5fop_5farray_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ZendOpArray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gphp.ZendOpArray) */ {
 public:
  ZendOpArray();
  virtual ~ZendOpArray();

  ZendOpArray(const ZendOpArray& from);

  inline ZendOpArray& operator=(const ZendOpArray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ZendOpArray(ZendOpArray&& from) noexcept
    : ZendOpArray() {
    *this = ::std::move(from);
  }

  inline ZendOpArray& operator=(ZendOpArray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ZendOpArray& default_instance();

  static inline const ZendOpArray* internal_default_instance() {
    return reinterpret_cast<const ZendOpArray*>(
               &_ZendOpArray_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ZendOpArray* other);
  friend void swap(ZendOpArray& a, ZendOpArray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ZendOpArray* New() const PROTOBUF_FINAL { return New(NULL); }

  ZendOpArray* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ZendOpArray& from);
  void MergeFrom(const ZendOpArray& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ZendOpArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .gphp.Opline opcodes = 1;
  int opcodes_size() const;
  void clear_opcodes();
  static const int kOpcodesFieldNumber = 1;
  const ::gphp::Opline& opcodes(int index) const;
  ::gphp::Opline* mutable_opcodes(int index);
  ::gphp::Opline* add_opcodes();
  ::google::protobuf::RepeatedPtrField< ::gphp::Opline >*
      mutable_opcodes();
  const ::google::protobuf::RepeatedPtrField< ::gphp::Opline >&
      opcodes() const;

  // repeated .gphp.Zval literals = 2;
  int literals_size() const;
  void clear_literals();
  static const int kLiteralsFieldNumber = 2;
  const ::gphp::Zval& literals(int index) const;
  ::gphp::Zval* mutable_literals(int index);
  ::gphp::Zval* add_literals();
  ::google::protobuf::RepeatedPtrField< ::gphp::Zval >*
      mutable_literals();
  const ::google::protobuf::RepeatedPtrField< ::gphp::Zval >&
      literals() const;

  // required uint32 var_size = 3;
  bool has_var_size() const;
  void clear_var_size();
  static const int kVarSizeFieldNumber = 3;
  ::google::protobuf::uint32 var_size() const;
  void set_var_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:gphp.ZendOpArray)
 private:
  void set_has_var_size();
  void clear_has_var_size();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::gphp::Opline > opcodes_;
  ::google::protobuf::RepeatedPtrField< ::gphp::Zval > literals_;
  ::google::protobuf::uint32 var_size_;
  friend struct protobuf_zend_5fop_5farray_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Opline

// required .gphp.Opcode opcode = 1;
inline bool Opline::has_opcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Opline::set_has_opcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Opline::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Opline::clear_opcode() {
  opcode_ = 0;
  clear_has_opcode();
}
inline ::gphp::Opcode Opline::opcode() const {
  // @@protoc_insertion_point(field_get:gphp.Opline.opcode)
  return static_cast< ::gphp::Opcode >(opcode_);
}
inline void Opline::set_opcode(::gphp::Opcode value) {
  assert(::gphp::Opcode_IsValid(value));
  set_has_opcode();
  opcode_ = value;
  // @@protoc_insertion_point(field_set:gphp.Opline.opcode)
}

// optional uint32 op1 = 2;
inline bool Opline::has_op1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Opline::set_has_op1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Opline::clear_has_op1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Opline::clear_op1() {
  op1_ = 0u;
  clear_has_op1();
}
inline ::google::protobuf::uint32 Opline::op1() const {
  // @@protoc_insertion_point(field_get:gphp.Opline.op1)
  return op1_;
}
inline void Opline::set_op1(::google::protobuf::uint32 value) {
  set_has_op1();
  op1_ = value;
  // @@protoc_insertion_point(field_set:gphp.Opline.op1)
}

// optional .gphp.Opline.OpType op1_type = 3;
inline bool Opline::has_op1_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Opline::set_has_op1_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Opline::clear_has_op1_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Opline::clear_op1_type() {
  op1_type_ = 1;
  clear_has_op1_type();
}
inline ::gphp::Opline_OpType Opline::op1_type() const {
  // @@protoc_insertion_point(field_get:gphp.Opline.op1_type)
  return static_cast< ::gphp::Opline_OpType >(op1_type_);
}
inline void Opline::set_op1_type(::gphp::Opline_OpType value) {
  assert(::gphp::Opline_OpType_IsValid(value));
  set_has_op1_type();
  op1_type_ = value;
  // @@protoc_insertion_point(field_set:gphp.Opline.op1_type)
}

// optional uint32 op2 = 4;
inline bool Opline::has_op2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Opline::set_has_op2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Opline::clear_has_op2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Opline::clear_op2() {
  op2_ = 0u;
  clear_has_op2();
}
inline ::google::protobuf::uint32 Opline::op2() const {
  // @@protoc_insertion_point(field_get:gphp.Opline.op2)
  return op2_;
}
inline void Opline::set_op2(::google::protobuf::uint32 value) {
  set_has_op2();
  op2_ = value;
  // @@protoc_insertion_point(field_set:gphp.Opline.op2)
}

// optional .gphp.Opline.OpType op2_type = 5;
inline bool Opline::has_op2_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Opline::set_has_op2_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Opline::clear_has_op2_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Opline::clear_op2_type() {
  op2_type_ = 1;
  clear_has_op2_type();
}
inline ::gphp::Opline_OpType Opline::op2_type() const {
  // @@protoc_insertion_point(field_get:gphp.Opline.op2_type)
  return static_cast< ::gphp::Opline_OpType >(op2_type_);
}
inline void Opline::set_op2_type(::gphp::Opline_OpType value) {
  assert(::gphp::Opline_OpType_IsValid(value));
  set_has_op2_type();
  op2_type_ = value;
  // @@protoc_insertion_point(field_set:gphp.Opline.op2_type)
}

// optional uint32 result = 6;
inline bool Opline::has_result() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Opline::set_has_result() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Opline::clear_has_result() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Opline::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 Opline::result() const {
  // @@protoc_insertion_point(field_get:gphp.Opline.result)
  return result_;
}
inline void Opline::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:gphp.Opline.result)
}

// optional .gphp.Opline.OpType result_type = 7;
inline bool Opline::has_result_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Opline::set_has_result_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Opline::clear_has_result_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Opline::clear_result_type() {
  result_type_ = 1;
  clear_has_result_type();
}
inline ::gphp::Opline_OpType Opline::result_type() const {
  // @@protoc_insertion_point(field_get:gphp.Opline.result_type)
  return static_cast< ::gphp::Opline_OpType >(result_type_);
}
inline void Opline::set_result_type(::gphp::Opline_OpType value) {
  assert(::gphp::Opline_OpType_IsValid(value));
  set_has_result_type();
  result_type_ = value;
  // @@protoc_insertion_point(field_set:gphp.Opline.result_type)
}

// optional uint32 extended_value = 8;
inline bool Opline::has_extended_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Opline::set_has_extended_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Opline::clear_has_extended_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Opline::clear_extended_value() {
  extended_value_ = 0u;
  clear_has_extended_value();
}
inline ::google::protobuf::uint32 Opline::extended_value() const {
  // @@protoc_insertion_point(field_get:gphp.Opline.extended_value)
  return extended_value_;
}
inline void Opline::set_extended_value(::google::protobuf::uint32 value) {
  set_has_extended_value();
  extended_value_ = value;
  // @@protoc_insertion_point(field_set:gphp.Opline.extended_value)
}

// optional uint32 lineno = 9;
inline bool Opline::has_lineno() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Opline::set_has_lineno() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Opline::clear_has_lineno() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Opline::clear_lineno() {
  lineno_ = 0u;
  clear_has_lineno();
}
inline ::google::protobuf::uint32 Opline::lineno() const {
  // @@protoc_insertion_point(field_get:gphp.Opline.lineno)
  return lineno_;
}
inline void Opline::set_lineno(::google::protobuf::uint32 value) {
  set_has_lineno();
  lineno_ = value;
  // @@protoc_insertion_point(field_set:gphp.Opline.lineno)
}

// -------------------------------------------------------------------

// ZendOpArray

// repeated .gphp.Opline opcodes = 1;
inline int ZendOpArray::opcodes_size() const {
  return opcodes_.size();
}
inline void ZendOpArray::clear_opcodes() {
  opcodes_.Clear();
}
inline const ::gphp::Opline& ZendOpArray::opcodes(int index) const {
  // @@protoc_insertion_point(field_get:gphp.ZendOpArray.opcodes)
  return opcodes_.Get(index);
}
inline ::gphp::Opline* ZendOpArray::mutable_opcodes(int index) {
  // @@protoc_insertion_point(field_mutable:gphp.ZendOpArray.opcodes)
  return opcodes_.Mutable(index);
}
inline ::gphp::Opline* ZendOpArray::add_opcodes() {
  // @@protoc_insertion_point(field_add:gphp.ZendOpArray.opcodes)
  return opcodes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::gphp::Opline >*
ZendOpArray::mutable_opcodes() {
  // @@protoc_insertion_point(field_mutable_list:gphp.ZendOpArray.opcodes)
  return &opcodes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::gphp::Opline >&
ZendOpArray::opcodes() const {
  // @@protoc_insertion_point(field_list:gphp.ZendOpArray.opcodes)
  return opcodes_;
}

// repeated .gphp.Zval literals = 2;
inline int ZendOpArray::literals_size() const {
  return literals_.size();
}
inline void ZendOpArray::clear_literals() {
  literals_.Clear();
}
inline const ::gphp::Zval& ZendOpArray::literals(int index) const {
  // @@protoc_insertion_point(field_get:gphp.ZendOpArray.literals)
  return literals_.Get(index);
}
inline ::gphp::Zval* ZendOpArray::mutable_literals(int index) {
  // @@protoc_insertion_point(field_mutable:gphp.ZendOpArray.literals)
  return literals_.Mutable(index);
}
inline ::gphp::Zval* ZendOpArray::add_literals() {
  // @@protoc_insertion_point(field_add:gphp.ZendOpArray.literals)
  return literals_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::gphp::Zval >*
ZendOpArray::mutable_literals() {
  // @@protoc_insertion_point(field_mutable_list:gphp.ZendOpArray.literals)
  return &literals_;
}
inline const ::google::protobuf::RepeatedPtrField< ::gphp::Zval >&
ZendOpArray::literals() const {
  // @@protoc_insertion_point(field_list:gphp.ZendOpArray.literals)
  return literals_;
}

// required uint32 var_size = 3;
inline bool ZendOpArray::has_var_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ZendOpArray::set_has_var_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ZendOpArray::clear_has_var_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ZendOpArray::clear_var_size() {
  var_size_ = 0u;
  clear_has_var_size();
}
inline ::google::protobuf::uint32 ZendOpArray::var_size() const {
  // @@protoc_insertion_point(field_get:gphp.ZendOpArray.var_size)
  return var_size_;
}
inline void ZendOpArray::set_var_size(::google::protobuf::uint32 value) {
  set_has_var_size();
  var_size_ = value;
  // @@protoc_insertion_point(field_set:gphp.ZendOpArray.var_size)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace gphp

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::gphp::Opline_OpType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gphp::Opline_OpType>() {
  return ::gphp::Opline_OpType_descriptor();
}
template <> struct is_proto_enum< ::gphp::Opcode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gphp::Opcode>() {
  return ::gphp::Opcode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_zend_5fop_5farray_2eproto__INCLUDED
